"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@keystonehq+alias-sampling@0.1.2";
exports.ids = ["vendor-chunks/@keystonehq+alias-sampling@0.1.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@keystonehq+alias-sampling@0.1.2/node_modules/@keystonehq/alias-sampling/dist/esm/index.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@keystonehq+alias-sampling@0.1.2/node_modules/@keystonehq/alias-sampling/dist/esm/index.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar precomputeAlias = function (p, n) {\n    var sum = p.reduce(function (acc, val) {\n        if (val < 0) {\n            throw new Error('Probability must be a positive: p[' + p.indexOf(val) + ']=' + val);\n        }\n        return acc + val;\n    }, 0);\n    if (sum === 0) {\n        throw new Error('Probability sum must be greater than zero.');\n    }\n    var scaledProbabilities = p.map(function (prob) { return (prob * n) / sum; });\n    var aliasData = { prob: new Array(n), alias: new Array(n) };\n    var small = [];\n    var large = [];\n    for (var i = n - 1; i >= 0; i--) {\n        if (scaledProbabilities[i] < 1) {\n            small.push(i);\n        }\n        else {\n            large.push(i);\n        }\n    }\n    while (small.length > 0 && large.length > 0) {\n        var less = small.pop();\n        var more = large.pop();\n        aliasData.prob[less] = scaledProbabilities[less];\n        aliasData.alias[less] = more;\n        scaledProbabilities[more] = (scaledProbabilities[more] + scaledProbabilities[less]) - 1;\n        if (scaledProbabilities[more] < 1) {\n            small.push(more);\n        }\n        else {\n            large.push(more);\n        }\n    }\n    while (large.length > 0) {\n        aliasData.prob[large.pop()] = 1;\n    }\n    while (small.length > 0) {\n        aliasData.prob[small.pop()] = 1;\n    }\n    return aliasData;\n};\nvar draw = function (aliasData, outcomes, rng) {\n    var c = Math.floor(rng() * aliasData.prob.length);\n    return outcomes[(rng() < aliasData.prob[c]) ? c : aliasData.alias[c]];\n};\nvar next = function (aliasData, outcomes, rng, numOfSamples) {\n    if (numOfSamples === void 0) { numOfSamples = 1; }\n    if (numOfSamples === 1) {\n        return draw(aliasData, outcomes, rng);\n    }\n    var samples = [];\n    for (var i = 0; i < numOfSamples; i++) {\n        samples.push(draw(aliasData, outcomes, rng));\n    }\n    return samples;\n};\nvar sample = function (probabilities, outcomes, rng) {\n    if (rng === void 0) { rng = Math.random; }\n    if (!Array.isArray(probabilities)) {\n        throw new Error('Probabilities must be an array.');\n    }\n    if (probabilities.length === 0) {\n        throw new Error('Probabilities array must not be empty.');\n    }\n    var n = probabilities.length;\n    var indexedOutcomes = outcomes !== null && outcomes !== void 0 ? outcomes : Array.from({ length: n }, function (_, i) { return i; });\n    var aliasData = precomputeAlias(probabilities, n);\n    return {\n        next: function (numOfSamples) {\n            if (numOfSamples === void 0) { numOfSamples = 1; }\n            return next(aliasData, indexedOutcomes, rng, numOfSamples);\n        }\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sample);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGtleXN0b25laHErYWxpYXMtc2FtcGxpbmdAMC4xLjIvbm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2FsaWFzLXNhbXBsaW5nL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQjtBQUNoRixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixXQUFXLG9CQUFvQixXQUFXO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE1BQU0sRUFBQyIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvaXdvLXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9Aa2V5c3RvbmVocSthbGlhcy1zYW1wbGluZ0AwLjEuMi9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYWxpYXMtc2FtcGxpbmcvZGlzdC9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHByZWNvbXB1dGVBbGlhcyA9IGZ1bmN0aW9uIChwLCBuKSB7XG4gICAgdmFyIHN1bSA9IHAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9iYWJpbGl0eSBtdXN0IGJlIGEgcG9zaXRpdmU6IHBbJyArIHAuaW5kZXhPZih2YWwpICsgJ109JyArIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYyArIHZhbDtcbiAgICB9LCAwKTtcbiAgICBpZiAoc3VtID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvYmFiaWxpdHkgc3VtIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgfVxuICAgIHZhciBzY2FsZWRQcm9iYWJpbGl0aWVzID0gcC5tYXAoZnVuY3Rpb24gKHByb2IpIHsgcmV0dXJuIChwcm9iICogbikgLyBzdW07IH0pO1xuICAgIHZhciBhbGlhc0RhdGEgPSB7IHByb2I6IG5ldyBBcnJheShuKSwgYWxpYXM6IG5ldyBBcnJheShuKSB9O1xuICAgIHZhciBzbWFsbCA9IFtdO1xuICAgIHZhciBsYXJnZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHNjYWxlZFByb2JhYmlsaXRpZXNbaV0gPCAxKSB7XG4gICAgICAgICAgICBzbWFsbC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFyZ2UucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoc21hbGwubGVuZ3RoID4gMCAmJiBsYXJnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBsZXNzID0gc21hbGwucG9wKCk7XG4gICAgICAgIHZhciBtb3JlID0gbGFyZ2UucG9wKCk7XG4gICAgICAgIGFsaWFzRGF0YS5wcm9iW2xlc3NdID0gc2NhbGVkUHJvYmFiaWxpdGllc1tsZXNzXTtcbiAgICAgICAgYWxpYXNEYXRhLmFsaWFzW2xlc3NdID0gbW9yZTtcbiAgICAgICAgc2NhbGVkUHJvYmFiaWxpdGllc1ttb3JlXSA9IChzY2FsZWRQcm9iYWJpbGl0aWVzW21vcmVdICsgc2NhbGVkUHJvYmFiaWxpdGllc1tsZXNzXSkgLSAxO1xuICAgICAgICBpZiAoc2NhbGVkUHJvYmFiaWxpdGllc1ttb3JlXSA8IDEpIHtcbiAgICAgICAgICAgIHNtYWxsLnB1c2gobW9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXJnZS5wdXNoKG1vcmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChsYXJnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFsaWFzRGF0YS5wcm9iW2xhcmdlLnBvcCgpXSA9IDE7XG4gICAgfVxuICAgIHdoaWxlIChzbWFsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFsaWFzRGF0YS5wcm9iW3NtYWxsLnBvcCgpXSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBhbGlhc0RhdGE7XG59O1xudmFyIGRyYXcgPSBmdW5jdGlvbiAoYWxpYXNEYXRhLCBvdXRjb21lcywgcm5nKSB7XG4gICAgdmFyIGMgPSBNYXRoLmZsb29yKHJuZygpICogYWxpYXNEYXRhLnByb2IubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0Y29tZXNbKHJuZygpIDwgYWxpYXNEYXRhLnByb2JbY10pID8gYyA6IGFsaWFzRGF0YS5hbGlhc1tjXV07XG59O1xudmFyIG5leHQgPSBmdW5jdGlvbiAoYWxpYXNEYXRhLCBvdXRjb21lcywgcm5nLCBudW1PZlNhbXBsZXMpIHtcbiAgICBpZiAobnVtT2ZTYW1wbGVzID09PSB2b2lkIDApIHsgbnVtT2ZTYW1wbGVzID0gMTsgfVxuICAgIGlmIChudW1PZlNhbXBsZXMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGRyYXcoYWxpYXNEYXRhLCBvdXRjb21lcywgcm5nKTtcbiAgICB9XG4gICAgdmFyIHNhbXBsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU9mU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHNhbXBsZXMucHVzaChkcmF3KGFsaWFzRGF0YSwgb3V0Y29tZXMsIHJuZykpO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlcztcbn07XG52YXIgc2FtcGxlID0gZnVuY3Rpb24gKHByb2JhYmlsaXRpZXMsIG91dGNvbWVzLCBybmcpIHtcbiAgICBpZiAocm5nID09PSB2b2lkIDApIHsgcm5nID0gTWF0aC5yYW5kb207IH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvYmFiaWxpdGllcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9iYWJpbGl0aWVzIG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgfVxuICAgIGlmIChwcm9iYWJpbGl0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2JhYmlsaXRpZXMgYXJyYXkgbXVzdCBub3QgYmUgZW1wdHkuJyk7XG4gICAgfVxuICAgIHZhciBuID0gcHJvYmFiaWxpdGllcy5sZW5ndGg7XG4gICAgdmFyIGluZGV4ZWRPdXRjb21lcyA9IG91dGNvbWVzICE9PSBudWxsICYmIG91dGNvbWVzICE9PSB2b2lkIDAgPyBvdXRjb21lcyA6IEFycmF5LmZyb20oeyBsZW5ndGg6IG4gfSwgZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGk7IH0pO1xuICAgIHZhciBhbGlhc0RhdGEgPSBwcmVjb21wdXRlQWxpYXMocHJvYmFiaWxpdGllcywgbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKG51bU9mU2FtcGxlcykge1xuICAgICAgICAgICAgaWYgKG51bU9mU2FtcGxlcyA9PT0gdm9pZCAwKSB7IG51bU9mU2FtcGxlcyA9IDE7IH1cbiAgICAgICAgICAgIHJldHVybiBuZXh0KGFsaWFzRGF0YSwgaW5kZXhlZE91dGNvbWVzLCBybmcsIG51bU9mU2FtcGxlcyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IHNhbXBsZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@keystonehq+alias-sampling@0.1.2/node_modules/@keystonehq/alias-sampling/dist/esm/index.js\n");

/***/ })

};
;